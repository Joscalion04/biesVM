<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/biesVM.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/biesVM.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
* Clase que representa una máquina virtual Bies, la cual ejecuta un conjunto de instrucciones
* 
* @author Manuel Mora Sandi 
* @author Derek Rojas Mendoza
* @author Josué Vindas Pérez
* @author Joseph León Cabezas
*/

class BiesVM {
  /**
  * Constructor de la máquina virtual Bies con un conjunto de instrucciones y un entorno global
  * @constructor
  * @param {string} code - Código fuente a ejecutar
  * @param {object} bindings - Entorno global
  * @param {object} contexts - Contextos de ejecución
  * @param {object} stack - Pila de ejecución
  */
  constructor() {
    this.code = []; // C
    this.stack = []; // S
    this.bindings = [[]]; // B
    this.contexts = []; // D
  }

  /**
  * Busca y devuelve la closure de una función por su nombre recorriendo los bindings 
  * desde el más reciente al más antiguo. Lanza un error si no se encuentra.
  *
  * @param functionName El nombre de la función a buscar.
  * @return La closure asociada a la función encontrada.
  * @throws Error Si la función no se encuentra en ningún binding.
  */
  findFunction(functionName) {
    for (let i = this.bindings.length - 1; i >= 0; i--) {
      if (this.bindings[i][functionName]) {
        return this.bindings[i][functionName]; // Retorna la closure
      }
    }
    throw new Error(`Función ${functionName} no encontrada`);
  }

  /**
  * Ejecuta una instrucción basada en el mnemónico proporcionado. La lógica varía 
  * dependiendo del tipo de instrucción, incluyendo operaciones aritméticas, lógicas,
  * manipulación de la pila y control de flujo.
  *
  * @param mnemonic El mnemónico de la instrucción a ejecutar.
  * @param args Los argumentos adicionales requeridos para la ejecución de la instrucción.
  */
  executeInstruction(mnemonic, args) { // instruction es el ctx del arbol
    // Lógica para ejecutar cada instrucción
    // Ejemplo: LDV, ADD, POP, etc.
    switch (mnemonic) {
      case 'INI': {

      } break;

      case 'HLT': {
        this.code = [];
        this.stack = [];
        this.bindings = [[]];
        this.contexts = [];
      } break;

      case 'PRN': {
        const N = this.stack.pop();
        console.log(N);
        this.stack.push(N);
      } break;

      case 'POP': {
        this.stack.pop();
      } break;

      case 'SWP': {
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N);
        this.stack.push(M);
      } break;

      case 'LDV': {
        const N = args[0];
        this.stack.push(N);
      } break;

      case 'BLD': {
        //console.log(this.bindings[args[0]][args[1]]);
        this.stack.push(this.bindings[args[0]][args[1]]);
      } break;

      case 'BST': {
        const K = this.stack.pop(); // Variable
        const E = parseInt(args[0]); // Binding
        const V = parseInt(args[1]); 
        this.bindings[E][V] = K;
      } break;

      case 'ADD': {
        const N = parseInt(this.stack.pop()); 
        const M = parseInt(this.stack.pop()); 
        if (typeof N === 'number' &amp;&amp; typeof M === 'number') {
          this.stack.push(N + M);
        }
      } break;

      case 'MUL': {
        const N = parseInt(this.stack.pop());
        const M = parseInt(this.stack.pop()); 
        if (typeof N === 'number' &amp;&amp; typeof M === 'number') {
          this.stack.push(N * M);
        }
      } break;

      case 'DIV': {
        const N = parseInt(this.stack.pop()); 
        const M = parseInt(this.stack.pop()); 
        if (typeof N === 'number' &amp;&amp; typeof M === 'number') {
          this.stack.push(N / M);
        }
      } break;

      case 'SUB': {
        const N = parseInt(this.stack.pop()); 
        const M = parseInt(this.stack.pop()); 
        if (typeof N === 'number' &amp;&amp; typeof M === 'number') {
          this.stack.push(N - M);
        }
      } break;
      // endregion Operaciones aritméticas
      case 'NEG': {
        const N = this.stack.pop();
        if (typeof N === 'number') {
          this.stack.push(-N);
        }
      } break;

      case 'SGN': {
        const N = this.stack.pop();
        if (typeof N === 'number') {
          this.stack.push(Math.sign(N) > 0 ? 1 : 0);//Revisar
        }
      } break;

      case 'EQ': {// Solo si son numeros?
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N === M ? 1 : 0);
      } break;

      case 'GT': {// Solo si son numeros?
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N > M ? 1 : 0);
      } break;

      case 'GTE': {// Solo si son numeros?
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N >= M ? 1 : 0);
      } break;

      case 'LT': {// Solo si son numeros?
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N &lt; M ? 1 : 0);
      } break;

      case 'LTE': {// Solo si son numeros?
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N &lt;= M ? 1 : 0);
      } break;

      case 'AND': {
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N &amp;&amp; M ? 1 : 0);
      } break;

      case 'OR': {
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N || M ? 1 : 0);
      } break;

      case 'XOR': {
        const N = this.stack.pop();
        const M = this.stack.pop();
        this.stack.push(N ^ M);// Funciona este operador?
      } break;

      case 'NOT': {
        const N = this.stack.pop();
        this.stack.push(!N ? 1 : 0);
      } break;

      case 'SNT': {
        const V = this.stack.pop();
        this.stack.push(V === "" ? 1 : 0);
      } break;

      case 'CAT': {
        const H1 = this.stack.pop();
        const H2 = this.stack.pop();
        this.stack.push(H1.concat(H2));
      } break;

      case 'TOS': {
        const V = this.stack.pop();
        this.stack.push(V.toString());
      } break;

      case 'LNT': {//?

      } break;

      case 'LIN': {
        const V = this.stack.pop();
        const L = this.stack.pop();
        L.unshift(V);
        this.stack.push(L);
      } break;

      case 'LTK': {
        const K = this.stack.pop();
        const V = this.stack.pop();
        this.stack.push(V[K]);//?
      } break;

      case 'LRK': {
        const K = this.stack.pop();
        const V = this.stack.pop();
        this.stack.push(V.slice(K));
      } break;

      case 'TOL': {
        const V = this.stack.pop();
        this.stack.push(Array.of(V));
      } break;

      case 'NOP': {
        // No hacer nada
      } break;
      
      case 'BR': {

      } break;

      case 'BF': {
          
      } break;

      case 'LDF': {
        const functionName = args[0];
        // Buscar la función en los bindings (closure = función + entorno)
        const closure = this.findFunction(functionName);
        this.stack.push(closure);
      } break;      

      case 'APP': {

      } break;
      
      case 'RET': {
        
      } break;

      case '$FUN': {
      
      } break;
    }
  }
}

export default BiesVM;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ArgContext.html">ArgContext</a></li><li><a href="BiesVM.html">BiesVM</a></li><li><a href="InstContext.html">InstContext</a></li><li><a href="MnemonicContext.html">MnemonicContext</a></li><li><a href="PrintVisitor.html">PrintVisitor</a></li><li><a href="StartContext.html">StartContext</a></li><li><a href="module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#arg">arg</a></li><li><a href="global.html#atn">atn</a></li><li><a href="global.html#decisionsToDFA">decisionsToDFA</a></li><li><a href="global.html#inst">inst</a></li><li><a href="global.html#mnemonic">mnemonic</a></li><li><a href="global.html#serializedATN">serializedATN</a></li><li><a href="global.html#sharedContextCache">sharedContextCache</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#test_parser">test_parser</a></li><li><a href="global.html#visitArg">visitArg</a></li><li><a href="global.html#visitInst">visitInst</a></li><li><a href="global.html#visitMnemonic">visitMnemonic</a></li><li><a href="global.html#visitStart">visitStart</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Sat Oct 05 2024 15:48:46 GMT-0600 (hora estándar central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
